<!DOCTYPE html>
<!-- saved from url=(0096)https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/ -->
<html lang="en-US" class="gr__ryancpeters_github_io">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=.9">
    <link rel="stylesheet" href="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/style.css">
    <!-- Begin Jekyll SEO tag v2.3.0 -->
    <title>Lecture 2: Huffman Coding | Winter_UWB_2017</title>
    <meta property="og:title" content="Lecture 2: Huffman Coding">
    <meta property="og:locale" content="en_US">
    <meta name="description" content="A repository for my coursework from winter of the 2017-2018 school year">
    <meta property="og:description" content="A repository for my coursework from winter of the 2017-2018 school year">
    <link rel="canonical" href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/">
    <meta property="og:url" content="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/">
    <meta property="og:site_name" content="Winter_UWB_2017">
    <script type="application/ld+json">
        {"name":null,"description":"A repository for my coursework from winter of the 2017-2018 school year","author":null,"@type":"WebPage","url":"https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/","image":null,"publisher":null,"headline":"Lecture 2: Huffman Coding","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}
    </script>
    <!-- End Jekyll SEO tag -->
</head>
<body data-gr-c-s-loaded="true">
    <header>
        <div class="container">
            <h1>Winter_UWB_2017</h1>
            <h2>A repository for my coursework from winter of the 2017-2018 school year</h2>
            <section id="downloads">

                <a href="http://courses.washington.edu/css343/pisan/" class="btn btn-github"><span class="icon"></span>Back to class Page</a>
            </section>
        </div>
    </header>
    <div class="container">
        <section id="main_content">
            <h1 id="lecture-2-huffman-coding">Lecture 2: Huffman Coding</h1>
            <h2 id="created-by-yusuf-pisan">Created By: Yusuf Pisan</h2>
            <p>formatted to Github Markdown syntax by Ryan Peters</p>
            <h2 id="be-sure-to-check-the-other-lectures-out-after-you-finish-this-one">Be sure to check the other lectures out after you finish this one!</h2>
            <p><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture1/">Previous lecture</a>&lt;————————————————————————&gt;<a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture3/">Next lecture</a></p>
            <hr>
            <h3 id="table-of-contents">Table of Contents</h3>
            <ul>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#huffman-coding">Huffman Coding</a></li>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#overview">Overview </a></li>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#assignment-1-turtleprogram">Assignment 1: TurtleProgram</a></li>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#common-programming-mistakes">Common Programming Mistakes</a></li>
                <li>
                    <a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#binary-search-tree---definition">Binary Search Tree - Definition</a>
                    <ul>
                        <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#binary-search-tree">Binary Search Tree</a></li>
                        <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#uml-for-binary-tree">UML for Binary Tree</a></li>
                        <li>
                            <a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#why-trees">Why Trees?</a>
                            <ul>
                                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#group-exercise-prove">Group Exercise: Prove</a></li>
                                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#group-exercise-prove---solution">Group Exercise: Prove - Solution</a></li>
                                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#group-exercise-insert-elements">Group Exercise: Insert Elements</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#tree-as-array">Tree as Array</a>
                    <ul>
                        <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#group-exercise-array-representation">Group Exercise: Array Representation</a></li>
                    </ul>
                </li>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#tree-as-linked-nodes">Tree as Linked Nodes</a></li>
                <li>
                    <a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#smart-pointers">Smart Pointers</a>
                    <ul>
                        <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#group-exercise-order-of-inserts">Group Exercise: Order of Inserts</a></li>
                    </ul>
                </li>
                <li>
                    <a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#huffman-coding">Huffman Coding</a>
                    <ul>
                        <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#huffman-coding---algorithm">Huffman Coding - Algorithm</a></li>
                    </ul>
                </li>
                <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#after-class">After Class</a></li>
            </ul>
            <hr>
            <h3 id="overview"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Overview</a><meta name="copyright" content="Yusuf Pisan | pisan@uw.edu | http://courses.washington.edu/css343/"><meta name="duration" content="120"></h3>
            <ul>
                <li>
                    <p>Review - Ass1, BST, Complexity Analysis (worksheet later)</p>
                </li>
                <li>
                    <p>Common programming mistakes</p>
                </li>
                <li>
                    <p>Binary Search Trees</p>
                </li>
                <li>
                    <p>Huffman Coding</p>
                </li>
                <li>
                    <p>See IDE Tips, email me tips!</p>
                </li>
            </ul>
            <hr>
            <h3 id="assignment-1-turtleprogram"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Assignment 1: TurtleProgram</a></h3>
            <p>Each program is a series of strings (comes as 2 strings at a time)</p>
            <p>Draw the UML Class Diagram - public functions, private variables</p>
            <p>Write the constructors and <code class="highlighter-rouge">&lt;&lt;</code> so you can easily display them</p>
            <p>You are overloading multiple operators <code class="highlighter-rouge">&lt;&lt; == != = + +=</code></p>
            <p>Signature must match (friend functions)</p>
            <p>Remember to dynamically allocate the array to be just the right size (not <code class="highlighter-rouge">string[100]</code>)</p>
            <ul>
                <li>
                    Optional: Smart pointers
                    <ul>
                        <li>Use unique_ptr for arrays, shared_ptr most other times</li>
                    </ul>
                </li>
            </ul>
            <hr>
            <h3 id="common-programming-mistakes"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Common Programming Mistakes</a></h3>
            <p>Use compiler flags <code class="highlighter-rouge">-Wall -Wextra -Wpedantic -Weffc++</code> and even <code class="highlighter-rouge">-Werror</code></p>
            <p>Review code examples: http://faculty.washington.edu/pisan/cpp/snippets.html</p>
            <hr>
            <h3 id="binary-search-tree---definition"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Binary Search Tree - Definition</a></h3>
            <ul>
                <li>
                    <p>Left child value less than parent</p>
                </li>
                <li>
                    <p>Right child value greater than parent</p>
                </li>
                <li>
                    <p>Assume no duplicates</p>
                </li>
            </ul>
            <p>Inserting items from a sorted list?</p>
            <ul>
                <li>Incremental Program Development</li>
            </ul>
            <p>Write a BST for <code class="highlighter-rouge">int</code> in the simplest way possible with only single constructor and <code class="highlighter-rouge">add</code>.</p>
            <p>Use the code from textbook. Generalize it to take any data type, to have proper getters/setters.</p>
            <p>Assignment #2 will use Trees.</p>
            <hr>
            <h3 id="binary-search-tree"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Binary Search Tree</a></h3>
<pre><code class="language-C++">search(BST, target)
  if (BST is empy)
    item not found
  else if target == data in BST
    item found
  else if target &lt; data
    search(left subtree, target)
  else
    search(right subtree, target)
</code></pre>
            <p>What is the worst case complexity for a badly constructed tree?</p>
            <p>Create a balanced BST for A, B, C, D, E, F</p>
            <p>What does it mean for a tree to be balanced, full, complete?</p>
            <hr>
            <h3 id="uml-for-binary-tree"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">UML for Binary Tree</a></h3>
            <p><img src="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/ch15-12-uml-binary-tree.png" alt="UML for BinaryTree"></p>
            <p>Implementation choices</p>
            <ul>
                <li>Arrays</li>
                <li>Link-Based</li>
            </ul>
            <hr>
            <h3 id="why-trees"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Why Trees?</a></h3>
            <ul>
                <li>
                    <p>Good for searching when there is both add/delete operations. Used internally for libraries</p>
                </li>
                <li>
                    <p>Games use Binary Space Partition, render only what is visible from front to back</p>
                </li>
                <li>
                    <p>Radix Trees for IP routing</p>
                </li>
                <li>
                    <p>Huffman Coding Tree for compression</p>
                </li>
                <li>
                    <p>GGM Trees for generating random numbers</p>
                </li>
                <li>
                    <p>Merkle Tree for cryptography</p>
                </li>
                <li>
                    <p>Syntax Tree for parsing languages</p>
                </li>
                <li>
                    <p>B-Tree for databases</p>
                </li>
                <li>
                    <p>Directory structures, web pages, anything hierarchical</p>
                </li>
            </ul>
            <hr>
            <h3 id="group-exercise-prove"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Group Exercise: Prove</a></h3>
            <p>Prove: A full binary tree of height ≥ 0 has 2<sup>h</sup> - 1 nodes</p>
            <p><img src="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/ch16-16-bst-full.png" alt=""></p>
            <hr>
            <h3 id="group-exercise-prove---solution"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Group Exercise: Prove - Solution</a></h3>
            <p><em>Prove:</em> A full binary tree of height ≥ 0  has 2<sup>h</sup> - 1 nodes</p>
            <p><strong><em>Proof by induction</em></strong></p>
            <p><strong>Basis:</strong>  When h = 0, the full binary tree is empty, and it contains 0 = 2<sup>0</sup> – 1 nodes</p>
            <p><strong>Inductive hypothesis:</strong> Assume that a full binary tree of height k has 2<sup>h</sup> – 1 nodes when 0 ≤ k &lt; h.</p>
            <p><strong><em>Inductive conclusion</em></strong></p>
            <p>We must show that a full binary tree of height h has 2<sup>h</sup> – 1 nodes</p>
            <p>
                Let’s look at a tree with height <code class="highlighter-rouge">h-1</code>.
                By the inductive hypothesis, T<sub>L</sub> and T<sub>R</sub> each have 2<sup>h-1</sup> – 1 nodes.
                The number of nodes in T is
            </p>
            <font size="6" style="font-family:courier;">
                1 (for root) + (number of nodes in T<sub>L</sub>) + (number of nodes in T<sub>R</sub>)
                = 1 + (2<sup>h-1</sup> – 1) + (2<sup>h-1</sup> – 1)
                = 1 + 2 x (2<sup>h-1</sup> – 1)
                = 1 + 2<sup>h</sup> - 2
                = 2<sup>h</sup> - 1
            </font>
            <hr>
            <h3 id="group-exercise-insert-elements"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Group Exercise: Insert Elements</a></h3>
            <p>Insert the letters in “Huffman Coding” to create a binary search tree</p>
            <ul>
                <li>
                    <p>Skip duplicates, treat all letters as lowercase</p>
                </li>
                <li>
                    <p>Write out the string that is created for preorder, inorder, postorder</p>
                </li>
                <li>
                    <p>What is the height of the tree (single root node = 1)</p>
                </li>
                <li>
                    <p>Can you reduce its height if it is a general tree and not a BST?</p>
                </li>
            </ul>
            <hr>
            <h3 id="tree-as-array"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Tree as Array</a></h3>
            <p>Not the most natural or common, but important</p>
<pre><code class="language-C++">TreeNode&lt;ItemType&gt; tree[MAX_NODES]; // array of nodes
int root; // index of root
int free; // index of free list
</code></pre>
<pre><code class="language-C++">class TreeNode
{   
private:
   ItemType item;        // Data portion
   int      leftChild;   // Index to left child
   int      rightChild;  // Index to right child
}
</code></pre>
            <p><img src="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/ch16-1-array.png" alt=""></p>
            <hr>
            <h3 id="group-exercise-array-representation"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Group Exercise: Array Representation</a></h3>
            <p>Represent “Huffman Coding” tree as an array</p>
            <ul>
                <li>Assume insertion order is as before H, u, f, …</li>
            </ul>
            <hr>
            <h3 id="tree-as-linked-nodes"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Tree as Linked Nodes</a></h3>
            <p><img src="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/ch16-2-link-based.png" alt=""></p>
<pre><code class="language-C++">class BinaryNode
{
private:
   int          item;          // Data portion
   BinaryNode * leftChildPtr;  // Pointer to left child
   BinaryNode * rightChildPtr; // Pointer to right child
}
</code></pre>
<pre><code class="language-C++">template&lt;class ItemType&gt;
class BinaryNode
{
private:
   ItemType                              item;          // Data portion
   BinaryNode&lt;ItemType&gt; * leftChildPtr;  // Pointer to left child
   BinaryNode&lt;ItemType&gt; * rightChildPtr; // Pointer to right child
}
</code></pre>
<pre><code class="language-C++">template&lt;class ItemType&gt;
class BinaryNode
{
private:
   ItemType                              item;          // Data portion
   shared_ptr&lt;BinaryNode&lt;ItemType&gt;&gt; leftChildPtr;  // Pointer to left child
   shared_ptr&lt;BinaryNode&lt;ItemType&gt;&gt; rightChildPtr; // Pointer to right child
}
</code></pre>
            <hr>
            <h3 id="smart-pointers"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Smart Pointers</a></h3>
            <p>shared_ptr - shared object, does reference counting, similar to regular pointer</p>
            <p>unique_ptr - unique ownership, nobody else can reference it</p>
            <p>weak_ptr - observer of the object, cannot be used to delete, does not add to reference count</p>
<pre><code class="language-C++">Box&lt;string&gt; myptr = new Box&lt;string&gt;();
shared_ptr&lt;Box&lt;string&gt;&gt; mysharedptr(new Box&lt;string&gt;());
...
delete myptr;
mysharedptr.reset();
</code></pre>
            <p>If interested, read C++ Interlude 4</p>
            <p>Using smart pointers is optional</p>
            <p><strong>Do not</strong> mix smart pointers and regular pointers</p>
            <hr>
            <h3 id="group-exercise-order-of-inserts"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Group Exercise: Order of Inserts</a></h3>
            <p><img src="./Lecture 2_ Huffman Coding _ Winter_UWB_2017_files/ch15-18-bintree.png" alt=""></p>
            <p>If this is our final binary search tree, find at least 2 possible insertion orders.</p>
            <hr>
            <h3 id="huffman-coding"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Huffman Coding</a></h3>
            <p>Used for compression (part of the gzip, jpeg and many other algorithm)</p>
            <p>Take advantage of repetitions</p>
            <p>Assign a code to each letter. Short codes for frequent letters.</p>
            <p>ASCII characters are represented as 8-bits. Lots of wasted space.</p>
            <div class="highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code>010011011001100110001110001
</code></pre>
                </div>
            </div>
            <p>Where does one code begin and the other one end? Need unique prefixes</p>
            <p>Extra: Details of gzip using LZ77 and Huffman at http://www.gzip.org/algorithm.txt</p>
            <p>
                and more from Mark Adler (co-author of zlib and gzip)<br>
                https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they
            </p>
            <hr>
            <h3 id="huffman-coding---algorithm"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">Huffman Coding - Algorithm</a></h3>
            <ul>
                <li>
                    <p>Each letter is a single node tree and has weight (w) based on its frequency</p>
                </li>
                <li>
                    <p>Combine the trees with lowest weights, the weight of the new tree is sum of the subtrees</p>
                </li>
                <li>
                    <p>Keep combining trees until there is a single node</p>
                </li>
                <li>
                    <p>Assign 0 to left branch, 1 to right branch to generate each letter’s code</p>
                </li>
                <li>
                    <p>Demo: <code class="highlighter-rouge">wood</code></p>
                </li>
            </ul>
<pre><code class="language-UML">Group Exercise: Free Beer
</code></pre>
            <ol>
                <li>
                    <p>Calculate number of times each letter appears</p>
                </li>
                <li>
                    <p>Create the Huffman Tree</p>
                </li>
                <li>
                    <p>Write out the code (not unique)</p>
                </li>
            </ol>
            <p>Extra:</p>
<pre><code class="language-UML">How much wood would a woodchuck chuck if a woodchuck could chuck wood?
</code></pre>
            <hr>
            <h3 id="after-class"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/#table-of-contents" title="Back to Table of Contents">After Class</a></h3>
            <ul>
                <li>Post to slack about some technical knowledge you are proud of</li>
                <li>Post tips or problems with CSS Linux Lab</li>
                <li>Work on Assignment-1</li>
                <li>
                    Work on creating Binary Search Trees
                    <ul>
                        <li>Start simple</li>
                    </ul>
                </li>
                <li>
                    Grader: Thomas Kercheval kercht@uw.edu
                    <ul>
                        <li>Available for questions on Friday Jan 12, 1-2pm in front of UW1-260Q</li>
                    </ul>
                </li>
            </ul>

        </section>
    </div>


</body>
</html>
