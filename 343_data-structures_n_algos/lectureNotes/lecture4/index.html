<!DOCTYPE html>
<!-- saved from url=(0096)https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/ -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/style.css">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Lecture 4: Binary Heaps &amp; Graphs | Winter_UWB_2017</title>
<meta property="og:title" content="Lecture 4: Binary Heaps &amp; Graphs">
<meta property="og:locale" content="en_US">
<meta name="description" content="A repository for my coursework from winter of the 2017-2018 school year">
<meta property="og:description" content="A repository for my coursework from winter of the 2017-2018 school year">
<link rel="canonical" href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/">
<meta property="og:url" content="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/">
<meta property="og:site_name" content="Winter_UWB_2017">
<script type="application/ld+json">
{"name":null,"description":"A repository for my coursework from winter of the 2017-2018 school year","author":null,"@type":"WebPage","url":"https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/","image":null,"publisher":null,"headline":"Lecture 4: Binary Heaps &amp; Graphs","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <h1>Winter_UWB_2017</h1>
        <h2>A repository for my coursework from winter of the 2017-2018 school year</h2>

        <section id="downloads">
          
          <a href="https://github.com/RyanCPeters/Winter_UWB_2017" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1 id="lecture-4-binary-heaps--graphs">Lecture 4: Binary Heaps &amp; Graphs</h1>

<h2 id="created-by-yusuf-pisan">Created by: Yusuf Pisan</h2>

<p>Formatted for GitHub Markdown syntax by Ryan Peters</p>

<h2 id="be-sure-to-check-the-other-lectures-out-after-you-finish-this-one">Be sure to check the other lectures out after you finish this one!</h2>

<p><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture3/">Previous Lecture</a>&lt;———————————————————————————————–</p>

<hr>

<h4 id="toc">ToC</h4>

<ul>
  <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#Overview">overview</a>
    <ul>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#const">const</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#runtime-polymorphism---virtual--overrid">Runtime polymorphism - virtual + override</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#decision-trees">Decision Trees</a></li>
    </ul>
  </li>
  <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap">Heap</a>
    <ul>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap---array-based-implementation">Heap - Array Based Implementation</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap---array-into-a-heap">Heap - Array into a Heap</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap---add">Heap - Add</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap---remove">Heap - Remove</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#implementing-priority-queue-as-a-heap">Implementing Priority Queue as a Heap</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#bst-vs-heap-in-implementing-priority-queue">BST vs Heap in Implementing Priority Queue</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#heap-sort---sort-an-arry-using-heap">Heap Sort - Sort an Arry Using Heap</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#group-exercise">Group Exercise</a></li>
    </ul>
  </li>
  <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#graphs">Graphs</a>
    <ul>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#graphs---implementing">Graphs - Implementing</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#graphs---searching">Graphs - Searching</a></li>
      <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#graphs---group-exercise">Graphs - Group Exercise</a></li>
    </ul>
  </li>
  <li><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#after-class">After Class</a></li>
</ul>

<hr>

<h3 id="overview"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Overview</a></h3>

<meta name="copyright" content="Yusuf Pisan | pisan@uw.edu | http://courses.washington.edu/css343/">
<meta name="duration" content="120">

<ul>
  <li>Review: Ass1, rebalancing tree during inserts, decision trees, const, priority queues, abstraction(?)</li>
  <li>JollyFeedback - automated tests</li>
  <li>Ass2: BinarySearchTree</li>
  <li>Big O Reading - Resources: Cracking the Coding Interview - VI Big O</li>
  <li>Binary Heaps</li>
  <li>Graphs</li>
</ul>

<hr>

<h3 id="const"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">const</a></h3>

<ul>
  <li>const to indicate that variable value does not change
    <pre><code class="language-C++">const int MAX{100};
</code></pre>
  </li>
  <li>const to indicate that a class member function does not modify the object
    <pre><code class="language-C++">void inorderTraverse(void visit(ItemType&amp;)) const;
</code></pre>
  </li>
  <li>const to indicate that the parameter passed by reference will not be modified
    <pre><code class="language-C++">bool add(const ItemType&amp; item);
</code></pre>
  </li>
  <li>const to indicate that the parameter returned is by reference, but cannot be changed
    <pre><code class="language-C++">// assume getName is a member function and returning a reference
// to a private variable in the class
const string&amp; getName() const;
</code></pre>
  </li>
  <li>
    <p>Do not return a reference or pointer to a local variable</p>
  </li>
  <li>const for pointer
    <pre><code class="language-C++">// read backwards: ptr is a pointer to an integer constant
// ptr cannot be used to change the value
const int * ptr;
</code></pre>
  </li>
</ul>

<p>https://isocpp.org/wiki/faq/const-correctness</p>

<hr>

<h3 id="runtime-polymorphism---virtual--override"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Runtime polymorphism - virtual + override</a></h3>

<ul>
  <li>Games: Bunch of different <code class="highlighter-rouge">graphical object</code>s</li>
  <li>All classes of objects have their own <code class="highlighter-rouge">draw()</code> function</li>
  <li>Base class defines it as <code class="highlighter-rouge">virtual void draw() const</code></li>
  <li>Derived classes define it as <code class="highlighter-rouge">void draw() const override</code></li>
  <li>So, we can have an array of pointers of type <code class="highlighter-rouge">graphical object</code> and use <code class="highlighter-rouge">go-&gt;draw()</code> to get the correct draw function</li>
</ul>

<p>http://www.cplusplus.com/doc/tutorial/polymorphism/</p>

<hr>

<h3 id="decision-trees"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Decision Trees</a></h3>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/decision-tree-knee.png" alt=""></p>

<hr>

<h3 id="heap"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap</a></h3>

<p>MaxHeap: Complete binary tree whose root is greater than its children</p>

<p>MinHeap: …</p>

<p>Not a binary search tree!</p>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/maxheap-minheap.png" alt=""></p>

<hr>

<h3 id="heap---array-based-implementation"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap - Array Based Implementation</a></h3>

<ul>
  <li>Heap has to be complete, filled from left to right</li>
  <li>
    <p>We know the index of each node based on level i</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- left: 2 * i + 1
- right: 2 * i + 2
- parent: (i - 1) / 2
</code></pre></div>    </div>
  </li>
</ul>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-as-array.png" alt=""></p>

<p>Keep track of <code class="highlighter-rouge">itemcount</code> and <code class="highlighter-rouge">maxItems</code></p>

<hr>

<h3 id="heap---array-into-a-heap"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap - Array into a Heap</a></h3>

<ul>
  <li>Start from rightmost leaf up to root, call heapRebuild</li>
</ul>
<pre><code class="language-C++">void heapCreate()
{
   // can simplify as itemCount / 2
   for (int index = itemCount - 1; index &gt;= 0; index--)
   {
      heapRebuild(index);  
   }
}  // end heapCreate
</code></pre>
  


<pre><code class="language-C++">void heapRebuild(const int subTreeNodeIndex)
{
   if (!isLeaf(subTreeNodeIndex))
   {
      // Find larger child
      int leftChildIndex = ...
      int rightChildIndex = ...
      int largerChildIndex = ...
      // Swap with larger child if node value is smaller
      if (items[largerChildIndex] &gt; items[subTreeNodeIndex])
      {
         swap(items[largerChildIndex], items[subTreeNodeIndex]);
         // Continue with the recursion at that child
         heapRebuild(largerChildIndex);
      }  // end if
   }  // end if
}  // end heapRebuild
</code></pre>

<hr>

<h3 id="heap---add"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap - Add</a></h3>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-add.png" alt=""></p>

<ul>
  <li>Add the new node to the next available spot</li>
  <li>Bubble up, swapping values with parent until Heap property restored</li>
  <li>Group Exercise: Add 50, Add 10</li>
</ul>

<hr>

<h3 id="heap---remove"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap - Remove</a></h3>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-remove.png" alt=""></p>

<ul>
  <li>Remove the node, we now have 2 semiheaps</li>
  <li>Last node that was added to the heap, becomes root</li>
  <li>Trickle down, swapping root value with child value (while child value larger)</li>
  <li>Group Exercise: Add 50, Add 10, Remove 5, Remove 6</li>
</ul>

<hr>

<h3 id="implementing-priority-queue-as-a-heap"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Implementing Priority Queue as a Heap</a></h3>

<p>Highest priority is at the root of MaxHeap</p>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/uml-adt-priorityqueue.png" alt=""></p>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/uml-heap.png" alt=""></p>

<hr>

<h3 id="bst-vs-heap-in-implementing-priority-queue"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">BST vs Heap in Implementing Priority Queue</a></h3>

<p>If we know the maximum number of items in priority queue, heap is better</p>

<p>Heap is blanced, BST can become unbalanced degrading performance</p>

<p>If multiple items have the same priority, we can maintain a list at the node</p>

<p>When last item in the list deleted, node is deleted</p>

<hr>

<h3 id="heap-sort---sort-an-arry-using-heap"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Heap Sort - Sort an Arry Using Heap</a></h3>

<ul>
  <li>Make the array into a heap</li>
  <li>Partition the array into Heap and Sorted parts</li>
  <li>Remove the root of the Heap, transfer it to Sorted</li>
  <li>Heap is smaller and has to be rebuilt. Sorted now has one more element</li>
  <li>Keep removing until Heap is empty</li>
</ul>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-sort1.png" alt=""></p>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-sort2.png" alt=""></p>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/heap-sort3.png" alt=""></p>

<hr>

<h3 id="group-exercise"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Group Exercise</a></h3>

<p>Start with array [25 30 20 80 40 60]</p>

<ol>
  <li>Turn the given array into a heap</li>
  <li>Sort the array by removing root at each turn - draw the array after each swap and heapRebuild</li>
</ol>

<ul>
  <li>Given a maxHeap, if one of the values in the heap changes, how do you restore the heap?</li>
</ul>

<hr>

<h3 id="graphs"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Graphs</a></h3>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/ch20-3-graph.png" alt=""></p>

<ul>
  <li>Directed/Undirected graphs</li>
</ul>

<hr>

<h3 id="graphs---implementing"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Graphs - Implementing</a></h3>

<ul>
  <li>
    <p>Adjacency Matrix</p><br/>
<img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/ch20-7-graph-adjacency.png" alt="">
  </li>
  <li>
    <p>Adjacency List</p><br/>
<img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/ch20-10-graph-adjacency-list.png" alt="">
  </li>
</ul>

<hr>

<h3 id="graphs---searching"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Graphs - Searching</a></h3>

<ul>
  <li>DFS - Depth-First Search
    <pre><code class="language-C++">dfs(v: Vertex) {
    s = a new stack
    s.push(v)
    Mark v as visited
    while (!s.isEmpty())
        if (no unvisited adj to vertex on top of stack)
              s.pop()
        else
            Select unvisited adj to vertex on top
            s.push(u)
            Mark u as visited
}
</code></pre>
  </li>
  <li>BFS - Breadth-First Search
    <pre><code class="language-C++">bfs(v: Vertex) {
q = new queue
q.enqueue(v)
Mark v as visited
while (!q.isEmpty())
      q.dequeue(w)
      for (each unvisited vertex u adjacent to w)
          Mark u as visited
          q.enqueue(u)
}
</code></pre>
  </li>
</ul>

<hr>

<h3 id="graphs---group-exercise"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">Graphs - Group Exercise</a></h3>

<p><img src="./Lecture 4_ Binary Heaps &amp; Graphs _ Winter_UWB_2017_files/ch20-12-graph.png" alt=""></p>

<ol>
  <li>DFS, start at i, looking for e, mark all nodes visited</li>
  <li>BFS, start at i, looking for e, mark all nodes visited</li>
</ol>

<hr>

<h3 id="after-class"><a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture4/#toc" title="Back To ToC">After Class</a></h3>

<ul>
  <li>Read: Chapter 20.1-3 (if you have not already)</li>
  <li>Read: Resources: Cracking the Coding Interview - VI Big O</li>
  <li>Start Ass-2, fix your Ass-1 if you have any memory leaks or not passing JollyFeedback with flying colors!</li>
</ul>


      </section>
    </div>

    
  

</body></html>
