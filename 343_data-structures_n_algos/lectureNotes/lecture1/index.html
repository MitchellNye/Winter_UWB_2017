<h1>Lecture 1 notes: Introduction &amp; Trees</h1>
<h2>Created By: Yusuf Pisan</h2>
<p>formatted to Github Markdown syntax by Ryan Peters</p>
<h2>Be sure to check the other lectures out after you finish this one!</h2>
<p>-----------------------------------------------------------------------------------------------&gt;<a href="https://ryancpeters.github.io/Winter_UWB_2017/343_data-structures_n_algos/lectureNotes/lecture2/">Next lecture</a></p>
<hr />
<h3>Table of Contents</h3>
<ol>
<li>Introduction and Trees</li>
<li><a href="#overview">Overview</a></li>
<li><a href="#342-review">342 Review</a></li>
<li><a href="#reading-code-1">Reading Code (1)</a></li>
<li><a href="#reading-code-2">Reading Code (2)</a></li>
<li><a href="#reading-code-3">Reading Code (3)</a></li>
<li><a href="#reading-code-4">Reading Code (4)</a></li>
<li><a href="#reading-code-5">Reading Code (5)</a></li>
<li><a href="#trees">Trees</a></li>
<li><a href="#algebraic-expression">Algebraic Expression</a></li>
<li><a href="#binary-search-tree">Binary Search Tree</a></li>
<li><a href="#after-class">After Class</a></li>
</ol>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Overview</a></h3>
<p>http://courses.washington.edu/css343/pisan/</p>
<ul>
<li>Syllabus</li>
<li>Contact Info, Office Hours</li>
<li>Textbooks</li>
<li>Grading</li>
<li>Weekly Schedule</li>
<li>
<p>Resources</p>
</li>
<li>
<p>About me</p>
</li>
<li>
<p>Readings before class</p>
</li>
</ul>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">342 Review</a></h3>
<ul>
<li>Searching &amp; Sorting</li>
<li>Recursion</li>
<li>Templates, STL</li>
<li>Binary Search Tree</li>
<li>Pointers, Linked Lists</li>
<li>Stacks (LIFO), Queues (FIFO)</li>
<li>Algorithm Analysis</li>
</ul>
<p>Order them based on your level of comfort<br />
https://pollev.com/pisan</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Reading Code (1)</a></h3>
<p>Somebody forgot to write comments! </p>
<p><code>C++++
int foo(int n)
{
   if (n  0)
      return 1;
   else
      return n * foo(n - 1);
}</code></p>
<p>What is its complexity? Why?</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Reading Code (2)</a></h3>
<p><code>C++
int mystery(const int anArray[], int first, int last, int target)
{
   int index;
   if (first &gt; last)
      index = -1;
   else
   {
      int mid = first + (last - first) / 2;
      if (target  anArray[mid])
         index = mid;
      else if (target &lt; anArray[mid])
         index = mystery(anArray, first, mid - 1, target);
      else
         index = mystery(anArray, mid + 1, last, target);
   }
   return index;
}</code></p>
<p>What is its complexity? Why?</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Reading Code (3)</a></h3>
<p>```C++
template<class ItemType>
bool Grouch<ItemType>::mumble(const ItemType&amp; newEntry)
{
   Node<ItemType>* nextNodePtr = new Node<ItemType>();
   nextNodePtr-&gt;setItem(newEntry);
   nextNodePtr-&gt;setNext(headPtr);</p>
<p>headPtr = nextNodePtr;        <br />
   itemCount++;</p>
<p>return true;
}  // end add
```</p>
<p>What is its complexity? Why?</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Reading Code (4)</a></h3>
<p>SomeInterface, but what?</p>
<p><code>C++
template&lt;class ItemType&gt;
class SomeInterface
{
public:
   virtual bool isEmpty() const = 0;
   virtual bool push(const ItemType&amp; newEntry) = 0;
   virtual bool pop() = 0;
   virtual ItemType peek() const = 0;
   virtual ~SomeInterface() {  }
};</code></p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Reading Code (5)</a></h3>
<p>```C++
template<class ItemType>
void someSort(ItemType theArray[], int n)
{
   bool sorted = false;
   int pass = 1;
   while (!sorted &amp;&amp; (pass &lt; n))
   {
      sorted = true;
      for (int index = 0; index &lt; n - pass; index++)
      {
         int nextIndex = index + 1;
         if (theArray[index] &gt; theArray[nextIndex])
         {
            std::swap(theArray[index], theArray[nextIndex]);
            sorted = false; // Signal exchange
         } // end if
      }  // end for</p>
<pre><code>  pass++;
</code></pre>
<p>}  // end while
}  // end someSort
```</p>
<p>What is its complexity? Why?</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Trees</a></h3>
<p><img alt="" src="./images/ch15-2-organization-tree.png" /></p>
<ul>
<li>Single root, hierarchical - more than one immediate successor</li>
<li>nodes, edges</li>
<li>child, parent, sibling, ancestor, descendant</li>
<li>subtree</li>
<li>general, n-ary, binary tree</li>
<li>height (root at level 1, empty tree has height 0)</li>
</ul>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Algebraic Expression</a></h3>
<p><img alt="Algebraic Expression" src="./images/ch15-3-algebraic-tree.png" /></p>
<p>Representing <code>(a - b) x c</code></p>
<ul>
<li>Traversal</li>
<li><em>preorder</em> - root, left, right  </li>
<li><em>inorder</em> - left, root, right  </li>
<li><em>postorder</em> - left, right, root</li>
</ul>
<p>Let's try different traversals.</p>
<p>Group Exercise: <code>((a + b) * (c + d)) / (e * f) - g</code></p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">Binary Search Tree</a></h3>
<p><code>C++
search(BST, target)
  if (BST is empy)
    item not found
  else if target  data in BST
    item found
  else if target &lt; data
    search(left subtree, target)
  else
    search(right subtree, target)</code></p>
<p>What is the worst case complexity for a badly constructed tree?</p>
<p>Create a balanced BST for A, B, C, D, E, F</p>
<hr />
<h3><a href="#table-of-contents" title="Back to Table of Contents">After Class</a></h3>
<p>Explore the Resources on course pages</p>
<p>Read/Review Binary Search Trees</p>
<p>Read Math (Rosen) 11.1-3 (available under Resources)</p>
<p>Logon to #slack https://css-uwb.slack.com/ join #343 and give an example of a programming error that you tend to make</p>
<p>Assignment 1: TurtleProgram<br />
  - Abstract Data Type (ADT) defines behavior. <br />
  - Data Structure is a concrete implementation of ADT<br />
  - Ask questions - but you have to debug your own code</p>
<p>Start programming </p>